"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFenString = void 0;
var types_1 = require("./types");
var InvalidFenError_1 = require("./InvalidFenError");
var validate_1 = require("./validate");
function parseFenString(fen) {
    var fenTokens = fen.split(" ");
    (0, validate_1.validateFen)(fenTokens);
    return {
        board: parseBoard(fenTokens),
        toMove: parseToMove(fenTokens),
        castlingRights: parseCastlingRights(fenTokens),
        enPassantSquare: parseEnPassantSquare(fenTokens),
        halfMoves: parseHalfMoves(fenTokens),
        fullMoves: parseFullMoves(fenTokens),
    };
}
exports.parseFenString = parseFenString;
function parseBoardChar(fenTokens, notation) {
    if (notation.match(/\d/)) {
        return Array(parseInt(notation, 10)).fill(types_1.EMPTY_SQUARE);
    }
    else if (notation in types_1.PIECES) {
        return [types_1.PIECES[notation]];
    }
    throw new InvalidFenError_1.InvalidFenError(fenTokens.join(" "));
}
function parseBoard(fenTokens) {
    return fenTokens[0].split("/").map(function (field) {
        var piecePlacements = [];
        for (var i = 0; i < field.length; i++) {
            piecePlacements.push.apply(piecePlacements, __spreadArray([], __read(parseBoardChar(fenTokens, field.charAt(i))), false));
        }
        return piecePlacements;
    });
}
function parseToMove(fenTokens) {
    return fenTokens[1] === "w" ? "white" : "black";
}
function parseCastlingRights(fenTokens) {
    return {
        white: {
            queenside: fenTokens[2].includes("Q"),
            kingside: fenTokens[2].includes("K"),
        },
        black: {
            queenside: fenTokens[2].includes("q"),
            kingside: fenTokens[2].includes("k"),
        },
    };
}
function parseHalfMoves(fenTokens) {
    return parseInt(fenTokens[4], 10);
}
function parseFullMoves(fenTokens) {
    return parseInt(fenTokens[5], 10);
}
function parseEnPassantSquare(fenTokens) {
    return fenTokens[3];
}
